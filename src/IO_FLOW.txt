# IO Flow - How Signals Get From GUI to PLC and Back

## The Basic Idea

Signals defined in XML → User maps them to addresses in GUI → IO handler exchanges data with PLC → Simulation sees the values

Force functionality lets you override any signal for testing.

## 1. Signal Definitions (XML Files)

Files: `IO/IO_treeList_<simulation>.xml`

Each simulation has its own XML with:
- **GeneralControls** - Common stuff (Start/Stop/Reset, general sliders)
- **Simulation-specific** - Tank valves, level sensors, etc

Each signal lists:
- Name (e.g., "DQValveIn")
- Type (bool/int)
- Range (0-1 for digital, 0-27648 for analog)
- IO prefix ("I" for inputs, "Q" for outputs)

When you switch simulations, the GUI loads the matching XML file automatically.

## 2. User Mapping (IO Config Page)

The IO config page (`ioConfigPage.py`) shows two parts:
- Left tree: Available signals from XML
- Right table: Mapped signals with addresses

User workflow:
1. Drag signal from tree to table
2. Assign byte/bit address (or use auto-assignment)
3. Optionally set byte offsets
4. Save to `IO_configuration.json`

**LOGO mode quirk**: Addresses display in LOGO format (V0.0, Q1, AQ2) but internally use standard S7 format (I0.0, Q0.0, QW2). The interpolator handles translation before conflict checks and after any address changes.

## 3. Force Functionality

Force lets you override any signal value for testing. Super useful for debugging without changing PLC code.

How it works:
- Enable force checkbox in IO table
- Set force value
- `get_forced_io_values()` collects all forced signals
- IO handler checks forced values FIRST, before PLC/simulation values

Force dict format:
```python
{
    "DQValveIn": True,       # Forced to ON
    "AQHeaterFraction": 15000  # Forced to specific analog value
}
```

Clears with one click via `clear_all_forces()`.

## 4. IO Handler (The Middleman)

File: `IO/handler.py`

Main job: Exchange data between PLC and simulation status

`updateIO()` does two things:

**A) PLC → Simulation (Read actuators):**
1. Read PLC outputs (Q bytes)
2. Check forced values first
3. Extract signal values using byte/bit addresses
4. Write to simulation status

**B) Simulation → PLC (Write sensors):**
1. Read simulation status (temperatures, levels, etc)
2. Check forced values first  
3. Apply byte offsets if configured
4. Write to PLC inputs (I bytes)

**Manual mode handling**: When manual mode is active, GUI values override PLC actuator outputs. The check looks like: `forced_values → manual mode values → PLC values` in that priority order.

**Important**: In manual mode with PLC connected, sensors still go to the PLC (so your PLC program can read them), but actuators come from GUI/forced values.

## 5. Protocol Manager

File: `core/protocolManager.py`

Handles the actual PLC communication. Abstracts away protocol differences so IO handler doesn't care if you're using LOGO, S7-1500, or PLCSim.

Each protocol implements:
- `GetDI/SetDI, GetDO/SetDO` - Digital IO
- `GetAI/SetAI, GetAO/SetAO` - Analog IO
- `connect/disconnect/isConnected` - Connection management

## 6. Main Loop Integration

File: `main.py`

The main loop ties everything together:

```
while running:
    Process Qt events
    
    if PLC connected:
        forced_values = get_forced_io_values()
        ioHandler.updateIO(plc, config, status, forced_values, manual_mode)
    else:
        ioHandler.resetOutputs()  # Zero out actuators
    
    sim_mgr.update_simulation(dt)  # Run physics
    update_tanksim_display()       # Refresh GUI
    
    # PLCSim gets extra processEvents() here for responsiveness
    if PLCSim_mode:
        app.processEvents()
```

**Timing quirk**: PLCSim uses min 50ms interval (vs 100ms+ for simulation) to keep GUI responsive. Each PLCSim API call through pythonnet has ~40-50ms overhead, so with 15-20 calls per cycle things can get sluggish without the extra processEvents().

## 7. GUI Mode (No PLC)

When `plcGuiControl == "gui"`:
- No PLC connection
- General Controls dock provides manual inputs
- Simulation runs standalone
- Good for testing simulation logic without hardware

## Signal Direction (Always Confusing)

From PLC perspective:
- **PLC Inputs (I)**: Simulator WRITES here (sensors going TO the PLC)
- **PLC Outputs (Q)**: Simulator READS here (actuators coming FROM the PLC)

Data flow:
```
Simulation sensors → IO Handler → PLC Inputs (I)
PLC Outputs (Q) → IO Handler → Simulation actuators
```

Force overrides can intercept at any point.

## Typical Workflow

1. Start app → Load PIDtankValve simulation
2. XML loaded → Signals appear in IO tree
3. Drag signals to table → Assign addresses (or let auto-assignment handle it)
4. Save config → Stored in IO_configuration.json
5. Connect to PLC → Protocol manager initializes
6. Main loop runs:
   - Read PLC outputs (with force overrides)
   - Update simulation physics
   - Write sensors to PLC (with offsets & force overrides)
7. User can force values anytime for testing
8. Disconnect → All actuators reset to 0

## Key Files Reference

- **XML Definitions**: `IO/IO_treeList_*.xml`
- **Config Storage**: `IO/IO_configuration.json`
- **IO Logic**: `IO/handler.py`
- **GUI Mapping**: `gui/pages/ioConfigPage.py`
- **Protocol Layer**: `core/protocolManager.py`
- **Main Loop**: `main.py`
- **Sim Config**: `simulations/PIDtankValve/config.py`
- **Sim State**: `simulations/PIDtankValve/status.py`
